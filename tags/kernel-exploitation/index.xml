<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Kernel Exploitation on theevilbit blog</title>
    <link>https://theevilbit.github.io/tags/kernel-exploitation/</link>
    <description>Recent content in Kernel Exploitation on theevilbit blog</description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Wed, 31 Jul 2019 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://theevilbit.github.io/tags/kernel-exploitation/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>A simple protection against HMValidateHandle technique</title>
      <link>https://theevilbit.github.io/posts/a_simple_protection_against_hmvalidatehandle_technique/</link>
      <pubDate>Wed, 31 Jul 2019 00:00:00 +0000</pubDate>
      <guid>https://theevilbit.github.io/posts/a_simple_protection_against_hmvalidatehandle_technique/</guid>
      <description>&lt;p&gt;In the recent days I was reading technical analysis of win32k exploits from recent years, and it caught my eyes, that the HMValidateHandle technique is very heavily used almost everywhere. Then I had an idea how to protect against this family of exploits, which I think is very simple. This post will be about that.&lt;/p&gt;&#xA;&lt;h2 id=&#34;what-is-hmvalidatehandle&#34;&gt;&#xA;  What is HMValidateHandle?&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#what-is-hmvalidatehandle&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;Link to heading&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;Link to heading&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;HMValidateHandle is an internal, unexported function of &lt;code&gt;user32.dll&lt;/code&gt;. It takes a handle and a handle type as arguments, and by looking up the handle table, if the handle is matching with the type it will copy the object to user memory. If the object contains a pointer to itself, like &lt;code&gt;tagWND&lt;/code&gt; it can be used to leak memory addresses from the kernel. This has been a known technique for very long time, I think the first mention of this was in Tarjei Mandt’s 2011 BlackHat US talk, you can find the PDF here: &lt;a href=&#34;https://media.blackhat.com/bh-us-11/Mandt/BH_US_11_Mandt_win32k_WP.pdf&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://media.blackhat.com/bh-us-11/Mandt/BH_US_11_Mandt_win32k_WP.pdf&lt;/a&gt;&#xA;There are awful lot of documentation about this, and it was widely abused in many-many Windows kernel exploits, as you could reliably leak kernel object addresses, especially useful for kernel pool spraying. Thus Microsoft decided to finally close this, and so this technique doesn’t work beyond Windows 10 RS4.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
