<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <meta name="author" content="Csaba Fitzl">
    
    

    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="CVE-2017-2533 - The details behind"/>
<meta name="twitter:description" content="Intro CVE-2017-2533 was part of a chain of vulnerabilities, used at pwn2own 2017 found by the phoenhex team. They wrote a blogpost about it here. This vulnerability led me to find CVE-2022-32780, which I detailed at Black Hat Asia 2022. Although the nature of CVE-2017-2533 was discussed by the authors, but the actual code part was never truly revealed, and I always wondered about the full details. Now I took the time to dig up the details, including how it was fixed, and why the fix solves the problem."/>

    <meta property="og:title" content="CVE-2017-2533 - The details behind" />
<meta property="og:description" content="Intro CVE-2017-2533 was part of a chain of vulnerabilities, used at pwn2own 2017 found by the phoenhex team. They wrote a blogpost about it here. This vulnerability led me to find CVE-2022-32780, which I detailed at Black Hat Asia 2022. Although the nature of CVE-2017-2533 was discussed by the authors, but the actual code part was never truly revealed, and I always wondered about the full details. Now I took the time to dig up the details, including how it was fixed, and why the fix solves the problem." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://theevilbit.github.io/posts/cve-2017-2533/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-08-29T00:00:00+00:00" />
<meta property="article:modified_time" content="2022-08-29T00:00:00+00:00" />



    
      <base href="https://theevilbit.github.io/posts/cve-2017-2533/">
    
    <title>
  CVE-2017-2533 - The details behind · theevilbit blog
</title>

    
      <link rel="canonical" href="https://theevilbit.github.io/posts/cve-2017-2533/">
    

    <link href="https://fonts.googleapis.com/css?family=Lato:400,700%7CMerriweather:300,700%7CSource+Code+Pro:400,700" rel="stylesheet">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.8.1/css/all.css" integrity="sha384-50oBUHEmvpQ+1lW4y57PTFmhCaXp0ML5d60M1M7uH2+nqUivzIebhndOJK28anvf" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css" integrity="sha256-l85OmPOjvil/SOvVt3HnSSjzF1TUMyT9eV0c2BzEGzU=" crossorigin="anonymous" />

    
      
      
      <link rel="stylesheet" href="https://theevilbit.github.io/css/coder.min.28d751104f30c16da1aa1bb04015cbe662cacfe0d1b01af4f2240ad58580069c.css" integrity="sha256-KNdREE8wwW2hqhuwQBXL5mLKz&#43;DRsBr08iQK1YWABpw=" crossorigin="anonymous" media="screen" />
    

    

    

    

    
    
    <link rel="icon" type="image/png" href="https://theevilbit.github.io/images/favicon-32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="https://theevilbit.github.io/images/favicon-16x16.png" sizes="16x16">

    <meta name="generator" content="Hugo 0.96.0" />
  </head>

  <body class=" ">
    <main class="wrapper">
      <nav class="navigation">
  <section class="container">
    <a class="navigation-title" href="https://theevilbit.github.io/">
      theevilbit blog
    </a>
    <input type="checkbox" id="menu-toggle" />
    <label class="menu-button float-right" for="menu-toggle"><i class="fas fa-bars"></i></label>
    <ul class="navigation-list">
      
        
          <li class="navigation-item">
            <a class="navigation-link" href="https://theevilbit.github.io/posts/">Posts</a>
          </li>
        
          <li class="navigation-item">
            <a class="navigation-link" href="https://theevilbit.github.io/shield/">Shield.app</a>
          </li>
        
          <li class="navigation-item">
            <a class="navigation-link" href="https://theevilbit.github.io/beyond/">Beyond good ol&#39; LaunchAgents</a>
          </li>
        
          <li class="navigation-item">
            <a class="navigation-link" href="https://theevilbit.github.io/tags/">Tags</a>
          </li>
        
          <li class="navigation-item">
            <a class="navigation-link" href="https://theevilbit.github.io/categories/">Categories</a>
          </li>
        
          <li class="navigation-item">
            <a class="navigation-link" href="https://theevilbit.github.io/about/">About</a>
          </li>
        
      
      
    </ul>
  </section>
</nav>


      <div class="content">
        
  <section class="container post">
    <article>
      <header>
        <div class="post-title">
          <h1 class="title">CVE-2017-2533 - The details behind</h1>
        </div>
        <div class="post-meta">
          <div class="date">
            <span class="posted-on">
              <i class="fas fa-calendar"></i>
              <time datetime='2022-08-29T00:00:00Z'>
                August 29, 2022
              </time>
            </span>
            <span class="reading-time">
              <i class="fas fa-clock"></i>
              10 minutes read
            </span>
          </div>
          <div class="categories">
  <i class="fas fa-folder"></i>
    <a href="https://theevilbit.github.io/categories/blog/">BLOG</a></div>

          <div class="tags">
  <i class="fas fa-tag"></i>
    <a href="https://theevilbit.github.io/tags/macos/">macos</a>
      <span class="separator">•</span>
    <a href="https://theevilbit.github.io/tags/lpe/">lpe</a>
      <span class="separator">•</span>
    <a href="https://theevilbit.github.io/tags/vulnerability/">vulnerability</a>
      <span class="separator">•</span>
    <a href="https://theevilbit.github.io/tags/cve/">cve</a></div>

        </div>
      </header>

      <div>
        <h2 id="intro">Intro</h2>
<p><a href="https://support.apple.com/en-us/HT207797">CVE-2017-2533</a>  was part of a chain of vulnerabilities, used at pwn2own 2017 found by the phoenhex team. They wrote a blogpost about it <a href="https://phoenhex.re/2017-06-09/pwn2own-diskarbitrationd-privesc">here</a>. This vulnerability led me to find CVE-2022-32780, which I detailed at <a href="https://www.blackhat.com/asia-22/briefings/schedule/index.html#macos-vulnerabilities-hiding-in-plain-sight-26073">Black Hat Asia 2022</a>. Although the nature of CVE-2017-2533 was discussed by the authors, but the actual code part was never truly revealed, and I always wondered about the full details. Now I took the time to dig up the details, including how it was fixed, and why the fix solves the problem.</p>
<h2 id="the-initial-info">The initial info</h2>
<p>CVE-2017-2533 is a race condition vulnerability impacting the Disk Arbitration service on macOS, allowing a user to escalate privileges to root. Disk Arbitration is open source, and the relevant code can be downloaded from Apple, link: <a href="https://opensource.apple.com/tarballs/DiskArbitration/DiskArbitration-288.1.1.tar.gz">https://opensource.apple.com/tarballs/DiskArbitration/DiskArbitration-288.1.1.tar.gz</a>. As per the authors, the relevant part from <code>DARequest.c</code> is the following.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>    <span style="color:#09f;font-style:italic">/*
</span></span></span><span style="display:flex;"><span><span style="color:#09f;font-style:italic">     * Determine whether the mount point is accessible by the user.
</span></span></span><span style="display:flex;"><span><span style="color:#09f;font-style:italic">     */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#069;font-weight:bold">if</span> ( DADiskGetDescription( disk, kDADiskDescriptionVolumePathKey ) <span style="color:#555">==</span> <span style="color:#366">NULL</span> )
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#069;font-weight:bold">if</span> ( DARequestGetUserUID( request ) )
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            CFTypeRef mountpoint;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            mountpoint <span style="color:#555">=</span> DARequestGetArgument2( request );
</span></span><span style="display:flex;"><span>            <span style="color:#09f;font-style:italic">// [...]
</span></span></span><span style="display:flex;"><span><span style="color:#09f;font-style:italic"></span>            <span style="color:#069;font-weight:bold">if</span> ( mountpoint )
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                <span style="color:#078;font-weight:bold">char</span> <span style="color:#555">*</span> path;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                path <span style="color:#555">=</span> ___CFURLCopyFileSystemRepresentation( mountpoint );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#069;font-weight:bold">if</span> ( path )
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    <span style="color:#069;font-weight:bold">struct</span> stat st;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                    <span style="color:#069;font-weight:bold">if</span> ( stat( path, <span style="color:#555">&amp;</span>st ) <span style="color:#555">==</span> <span style="color:#f60">0</span> )
</span></span><span style="display:flex;"><span>                    {
</span></span><span style="display:flex;"><span>                        <span style="color:#069;font-weight:bold">if</span> ( st.st_uid <span style="color:#555">!=</span> DARequestGetUserUID( request ) )
</span></span><span style="display:flex;"><span>                        {
</span></span><span style="display:flex;"><span>                            <span style="color:#09f;font-style:italic">// [[ 1 ]]
</span></span></span><span style="display:flex;"><span><span style="color:#09f;font-style:italic"></span>                            status <span style="color:#555">=</span> kDAReturnNotPermitted;
</span></span><span style="display:flex;"><span>                        }
</span></span><span style="display:flex;"><span>                    }
</span></span></code></pre></div><p>The authors say the following:</p>
<blockquote>
<p>The mechanism implemented here is supposed to prevent a user with mount privileges to mount over a directory they do not own, such as /etc or /System. It works as follows: If the mount point exists, but is not owned by the user, the error code kDAReturnNotPermitted is produced at [[ 1 ]]. Otherwise, the mount proceeds. There are no more checks after this and the mount will succeed if the intended mount point exists and diskarbitrationd has sufficient permissions to perform the mount.<br>
&hellip;<br>
There is an old school <em>time of check vs. time of use</em> issue here: If the mount point is created after the check, but before the mount, the mount can succeed even if the caller does not own the mount point. An attacker can bypass the check by creating a symlink pointing to an arbitrary directory between the check and the mount.</p>
</blockquote>
<p>So there is a race condition issue between the check performed at <code>if ( st.st_uid != DARequestGetUserUID( request ) )</code> and the execution of the mount operation. But why exactly? Other parts of the source code was not referenced. Also, Apple&rsquo;s fix in High Sierra 10.12.5, and Disk Arbitration 288.60.1 (download: <a href="https://github.com/apple-oss-distributions/DiskArbitration/archive/DiskArbitration-288.60.1.tar.gz">https://github.com/apple-oss-distributions/DiskArbitration/archive/DiskArbitration-288.60.1.tar.gz</a>) is essentially a one line modification: <code>if ( DARequestGetUserUID( request ) != DADiskGetUserUID( disk ) )</code>. So why <code>DADiskGetUserUID( disk )</code> is better than <code>st.st_uid</code>? That was also never answered.</p>
<p>So let&rsquo;s find out all the details, where the mountpoint path is important. Here I will use the original source code, version 288.1.1. It took me some time to put together the pieces, and I hope I got it right. So here you go, split into multiple parts.</p>
<h2 id="one---the-disk">One - The Disk</h2>
<p>The DA service has an abstraction for a disk device, called <code>DADisk</code> which we can usually find as <code>/dev/disk*</code> in the file system, or list them with <code>diskutil list</code>. DA will maintain a list of disks internally. The API is public, we can also create those references for ourselves, like <code>DADiskCreateFromVolumePath</code>, more details can be found here: <a href="https://developer.apple.com/documentation/diskarbitration/1401858-dadiskcreatefromvolumepath">Apple Developer Documentation</a>.</p>
<p>The full code of <code>DADiskCreateFromVolumePath</code>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>DADiskRef <span style="color:#c0f">DADiskCreateFromVolumePath</span>( CFAllocatorRef allocator, <span style="color:#069;font-weight:bold">const</span> <span style="color:#069;font-weight:bold">struct</span> statfs <span style="color:#555">*</span> fs )
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    DADiskRef disk;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    disk <span style="color:#555">=</span> <span style="color:#366">NULL</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#069;font-weight:bold">if</span> ( fs )
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        CFURLRef path;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        path <span style="color:#555">=</span> CFURLCreateFromFileSystemRepresentation( kCFAllocatorDefault, ( <span style="color:#078;font-weight:bold">void</span> <span style="color:#555">*</span> ) fs<span style="color:#555">-&gt;</span>f_mntonname, strlen( fs<span style="color:#555">-&gt;</span>f_mntonname ), TRUE );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#069;font-weight:bold">if</span> ( path )
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            CFStringRef kind;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            kind <span style="color:#555">=</span> CFStringCreateWithCString( kCFAllocatorDefault, fs<span style="color:#555">-&gt;</span>f_fstypename, kCFStringEncodingUTF8 );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#069;font-weight:bold">if</span> ( kind )
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                <span style="color:#078;font-weight:bold">char</span> <span style="color:#555">*</span> id;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                id <span style="color:#555">=</span> _DAVolumeCopyID( fs );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#069;font-weight:bold">if</span> ( id )
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    CFTypeRef object;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                    disk <span style="color:#555">=</span> __DADiskCreate( allocator, id );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                    <span style="color:#069;font-weight:bold">if</span> ( disk )
</span></span><span style="display:flex;"><span>                    {
</span></span><span style="display:flex;"><span>                        <span style="color:#069;font-weight:bold">struct</span> passwd <span style="color:#555">*</span> user;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                        disk<span style="color:#555">-&gt;</span>_bypath <span style="color:#555">=</span> CFRetain( path );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                        CFDictionarySetValue( disk<span style="color:#555">-&gt;</span>_description, kDADiskDescriptionVolumePathKey, path );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                        CFDictionarySetValue( disk<span style="color:#555">-&gt;</span>_description, kDADiskDescriptionVolumeMountableKey, kCFBooleanTrue );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                        CFDictionarySetValue( disk<span style="color:#555">-&gt;</span>_description, kDADiskDescriptionVolumeKindKey, kind );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                        object <span style="color:#555">=</span> _DAFileSystemCopyName( <span style="color:#366">NULL</span>, path );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                        <span style="color:#069;font-weight:bold">if</span> ( object )
</span></span><span style="display:flex;"><span>                        {
</span></span><span style="display:flex;"><span>                            CFDictionarySetValue( disk<span style="color:#555">-&gt;</span>_description, kDADiskDescriptionVolumeNameKey, object );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                            CFRelease( object );
</span></span><span style="display:flex;"><span>                        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                        <span style="color:#069;font-weight:bold">if</span> ( ( fs<span style="color:#555">-&gt;</span>f_flags <span style="color:#555">&amp;</span> MNT_LOCAL ) )
</span></span><span style="display:flex;"><span>                        {
</span></span><span style="display:flex;"><span>                            CFDictionarySetValue( disk<span style="color:#555">-&gt;</span>_description, kDADiskDescriptionVolumeNetworkKey, kCFBooleanFalse );
</span></span><span style="display:flex;"><span>                        }
</span></span><span style="display:flex;"><span>                        <span style="color:#069;font-weight:bold">else</span>
</span></span><span style="display:flex;"><span>                        {
</span></span><span style="display:flex;"><span>                            CFDictionarySetValue( disk<span style="color:#555">-&gt;</span>_description, kDADiskDescriptionVolumeNetworkKey, kCFBooleanTrue );
</span></span><span style="display:flex;"><span>                        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                        disk<span style="color:#555">-&gt;</span>_state <span style="color:#555">|=</span> _kDADiskStateMountAutomatic;
</span></span><span style="display:flex;"><span>                        disk<span style="color:#555">-&gt;</span>_state <span style="color:#555">|=</span> _kDADiskStateMountAutomaticNoDefer;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                        disk<span style="color:#555">-&gt;</span>_state <span style="color:#555">|=</span> kDADiskStateStagedProbe;
</span></span><span style="display:flex;"><span>                        disk<span style="color:#555">-&gt;</span>_state <span style="color:#555">|=</span> kDADiskStateStagedPeek;
</span></span><span style="display:flex;"><span>                        disk<span style="color:#555">-&gt;</span>_state <span style="color:#555">|=</span> kDADiskStateStagedMount;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                        disk<span style="color:#555">-&gt;</span>_userUID <span style="color:#555">=</span> fs<span style="color:#555">-&gt;</span>f_owner;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                        user <span style="color:#555">=</span> getpwuid( fs<span style="color:#555">-&gt;</span>f_owner );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                        <span style="color:#069;font-weight:bold">if</span> ( user )
</span></span><span style="display:flex;"><span>                        {
</span></span><span style="display:flex;"><span>                            disk<span style="color:#555">-&gt;</span>_userGID <span style="color:#555">=</span> user<span style="color:#555">-&gt;</span>pw_gid;
</span></span><span style="display:flex;"><span>                        }
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                    free( id );
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                CFRelease( kind );
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            CFRelease( path );
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#069;font-weight:bold">return</span> disk;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Here the important part is the following. When the disk is created, we get the user ID and group ID based on the <code>statfs</code> structure, which also contains ownership information.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>disk<span style="color:#555">-&gt;</span>_userUID <span style="color:#555">=</span> fs<span style="color:#555">-&gt;</span>f_owner;
</span></span><span style="display:flex;"><span>disk<span style="color:#555">-&gt;</span>_userGID <span style="color:#555">=</span> user<span style="color:#555">-&gt;</span>pw_gid;
</span></span></code></pre></div><p>This is essentially the owner who created or mounted the <code>/dev/</code> device. We can also check this in Terminal.</p>
<pre tabindex="0"><code>csaby@mantarey ~ % ls -l /dev/disk*
brw-r-----  1 root   operator  0x1000000 Aug 23 15:20 /dev/disk0
brw-r-----  1 root   operator  0x1000001 Aug 23 15:20 /dev/disk0s1
brw-r-----  1 root   operator  0x1000002 Aug 23 15:20 /dev/disk0s2
brw-r-----  1 root   operator  0x1000003 Aug 23 15:20 /dev/disk1
brw-r-----  1 root   operator  0x1000004 Aug 23 15:20 /dev/disk1s1
brw-r-----  1 root   operator  0x1000005 Aug 23 15:20 /dev/disk1s2
brw-r-----  1 root   operator  0x1000008 Aug 23 15:20 /dev/disk1s3
brw-r-----  1 root   operator  0x1000006 Aug 23 15:20 /dev/disk1s4
brw-r-----  1 root   operator  0x1000009 Aug 23 15:20 /dev/disk1s5
br--r-----  1 root   operator  0x100000a Aug 23 15:20 /dev/disk1s5s1
brw-r-----  1 root   operator  0x1000007 Aug 23 15:20 /dev/disk1s6
brw-r-----  1 csaby  staff     0x100000b Aug 29 19:33 /dev/disk2
brw-r-----  1 csaby  staff     0x100000c Aug 29 19:33 /dev/disk2s1
brw-r-----  1 csaby  staff     0x100000d Aug 29 19:33 /dev/disk3
brw-r-----  1 csaby  staff     0x100000e Aug 29 19:33 /dev/disk3s1
</code></pre><p>Later <code>DADiskGetUserUID</code> simply retrieves the userID (<code>DADisk.c</code>).</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>uid_t <span style="color:#c0f">DADiskGetUserUID</span>( DADiskRef disk )
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#069;font-weight:bold">return</span> disk<span style="color:#555">-&gt;</span>_userUID;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>So we store the owner of the disk. Let&rsquo;s keep this in mind for now.</p>
<h2 id="two---the-mount-call">Two - The mount call</h2>
<p>When DA does the actual mounting (implemented in <code>DAMount.c</code>) it takes the user ID from the disk owner. This is done in <code>DADiskGetUserUID( context-&gt;disk )</code>.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#069;font-weight:bold">static</span> <span style="color:#078;font-weight:bold">void</span> <span style="color:#c0f">__DAMountWithArgumentsCallbackStage1</span>( <span style="color:#078;font-weight:bold">int</span> status, <span style="color:#078;font-weight:bold">void</span> <span style="color:#555">*</span> parameter )
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>           DAFileSystemMountWithArguments( DADiskGetFileSystem( context<span style="color:#555">-&gt;</span>disk ),
</span></span><span style="display:flex;"><span>                                            DADiskGetDevice( context<span style="color:#555">-&gt;</span>disk ),
</span></span><span style="display:flex;"><span>                                            context<span style="color:#555">-&gt;</span>mountpoint,
</span></span><span style="display:flex;"><span>                                            DADiskGetUserUID( context<span style="color:#555">-&gt;</span>disk ),
</span></span><span style="display:flex;"><span>                                            DADiskGetUserGID( context<span style="color:#555">-&gt;</span>disk ),
</span></span><span style="display:flex;"><span>                                            __DAMountWithArgumentsCallbackStage2,
</span></span><span style="display:flex;"><span>                                            context,
</span></span><span style="display:flex;"><span>                                            context<span style="color:#555">-&gt;</span>options,
</span></span><span style="display:flex;"><span>                                            <span style="color:#366">NULL</span> );
</span></span></code></pre></div><p><code>DAFileSystemMountWithArguments</code> can be found in <code>DAFileSystem.c</code>. It will eventually call <code>DACommandExecute</code> with dynamically creating a mount command with arguments also passing along the UID and GID.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#078;font-weight:bold">void</span> <span style="color:#c0f">DAFileSystemMountWithArguments</span>( DAFileSystemRef      filesystem,
</span></span><span style="display:flex;"><span>                                     CFURLRef             device,
</span></span><span style="display:flex;"><span>                                     CFURLRef             mountpoint,
</span></span><span style="display:flex;"><span>                                     uid_t                userUID,
</span></span><span style="display:flex;"><span>                                     gid_t                userGID,
</span></span><span style="display:flex;"><span>                                     DAFileSystemCallback callback,
</span></span><span style="display:flex;"><span>                                     <span style="color:#078;font-weight:bold">void</span> <span style="color:#555">*</span>               callbackContext,
</span></span><span style="display:flex;"><span>                                     ... )
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#09f;font-style:italic">/*
</span></span></span><span style="display:flex;"><span><span style="color:#09f;font-style:italic">     * Mount the specified volume.  A status of 0 indicates success.  All arguments in
</span></span></span><span style="display:flex;"><span><span style="color:#09f;font-style:italic">     * the argument list shall be of type CFStringRef.  The argument list must be NULL
</span></span></span><span style="display:flex;"><span><span style="color:#09f;font-style:italic">     * terminated.
</span></span></span><span style="display:flex;"><span><span style="color:#09f;font-style:italic">     */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    CFStringRef             argument       <span style="color:#555">=</span> <span style="color:#366">NULL</span>;
</span></span><span style="display:flex;"><span>    va_list                 arguments;
</span></span><span style="display:flex;"><span>    CFURLRef                command        <span style="color:#555">=</span> <span style="color:#366">NULL</span>;
</span></span><span style="display:flex;"><span>    __DAFileSystemContext <span style="color:#555">*</span> context        <span style="color:#555">=</span> <span style="color:#366">NULL</span>;
</span></span><span style="display:flex;"><span>    CFStringRef             devicePath     <span style="color:#555">=</span> <span style="color:#366">NULL</span>;
</span></span><span style="display:flex;"><span>    CFStringRef             mountpointPath <span style="color:#555">=</span> <span style="color:#366">NULL</span>;
</span></span><span style="display:flex;"><span>    CFMutableStringRef      options        <span style="color:#555">=</span> <span style="color:#366">NULL</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#078;font-weight:bold">int</span>                     status         <span style="color:#555">=</span> <span style="color:#f60">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#09f;font-style:italic">/*
</span></span></span><span style="display:flex;"><span><span style="color:#09f;font-style:italic">     * Prepare to mount the volume.
</span></span></span><span style="display:flex;"><span><span style="color:#09f;font-style:italic">     */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    command <span style="color:#555">=</span> CFURLCreateWithFileSystemPath( kCFAllocatorDefault, CFSTR( <span style="color:#c30">&#34;/sbin/mount&#34;</span> ), kCFURLPOSIXPathStyle, FALSE );
</span></span><span style="display:flex;"><span>    <span style="color:#069;font-weight:bold">if</span> ( command <span style="color:#555">==</span> <span style="color:#366">NULL</span> )  { status <span style="color:#555">=</span> ENOTSUP; <span style="color:#069;font-weight:bold">goto</span> DAFileSystemMountErr; }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    context <span style="color:#555">=</span> malloc( <span style="color:#069;font-weight:bold">sizeof</span>( __DAFileSystemContext ) );
</span></span><span style="display:flex;"><span>    <span style="color:#069;font-weight:bold">if</span> ( context <span style="color:#555">==</span> <span style="color:#366">NULL</span> )  { status <span style="color:#555">=</span> ENOMEM; <span style="color:#069;font-weight:bold">goto</span> DAFileSystemMountErr; }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    devicePath <span style="color:#555">=</span> CFURLCopyFileSystemPath( device, kCFURLPOSIXPathStyle );
</span></span><span style="display:flex;"><span>    <span style="color:#069;font-weight:bold">if</span> ( devicePath <span style="color:#555">==</span> <span style="color:#366">NULL</span> )  { status <span style="color:#555">=</span> EINVAL; <span style="color:#069;font-weight:bold">goto</span> DAFileSystemMountErr; }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    mountpointPath <span style="color:#555">=</span> CFURLCopyFileSystemPath( mountpoint, kCFURLPOSIXPathStyle );
</span></span><span style="display:flex;"><span>    <span style="color:#069;font-weight:bold">if</span> ( mountpointPath <span style="color:#555">==</span> <span style="color:#366">NULL</span> )  { status <span style="color:#555">=</span> EINVAL; <span style="color:#069;font-weight:bold">goto</span> DAFileSystemMountErr; }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    options <span style="color:#555">=</span> CFStringCreateMutable( kCFAllocatorDefault, <span style="color:#f60">0</span> );
</span></span><span style="display:flex;"><span>    <span style="color:#069;font-weight:bold">if</span> ( options <span style="color:#555">==</span> <span style="color:#366">NULL</span> )  { status <span style="color:#555">=</span> ENOMEM; <span style="color:#069;font-weight:bold">goto</span> DAFileSystemMountErr; }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#09f;font-style:italic">/*
</span></span></span><span style="display:flex;"><span><span style="color:#09f;font-style:italic">     * Prepare the mount options.
</span></span></span><span style="display:flex;"><span><span style="color:#09f;font-style:italic">     */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    va_start( arguments, callbackContext );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#069;font-weight:bold">while</span> ( ( argument <span style="color:#555">=</span> va_arg( arguments, CFStringRef ) ) )
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        CFStringAppend( options, argument );
</span></span><span style="display:flex;"><span>        CFStringAppend( options, CFSTR( <span style="color:#c30">&#34;,&#34;</span> ) );
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    va_end( arguments );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    CFStringTrim( options, CFSTR( <span style="color:#c30">&#34;,&#34;</span> ) );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#09f;font-style:italic">/*
</span></span></span><span style="display:flex;"><span><span style="color:#09f;font-style:italic">     * Execute the mount command.
</span></span></span><span style="display:flex;"><span><span style="color:#09f;font-style:italic">     */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    context<span style="color:#555">-&gt;</span>callback        <span style="color:#555">=</span> callback;
</span></span><span style="display:flex;"><span>    context<span style="color:#555">-&gt;</span>callbackContext <span style="color:#555">=</span> callbackContext;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#069;font-weight:bold">if</span> ( CFStringGetLength( options ) )
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        DACommandExecute( command,
</span></span><span style="display:flex;"><span>                          kDACommandExecuteOptionDefault,
</span></span><span style="display:flex;"><span>                          userUID,
</span></span><span style="display:flex;"><span>                          userGID,
</span></span><span style="display:flex;"><span>                          __DAFileSystemCallback,
</span></span><span style="display:flex;"><span>                          context,
</span></span><span style="display:flex;"><span>                          CFSTR( <span style="color:#c30">&#34;-t&#34;</span> ),
</span></span><span style="display:flex;"><span>                          DAFileSystemGetKind( filesystem ),
</span></span><span style="display:flex;"><span>                          CFSTR( <span style="color:#c30">&#34;-o&#34;</span> ),
</span></span><span style="display:flex;"><span>                          options,
</span></span><span style="display:flex;"><span>                          devicePath,
</span></span><span style="display:flex;"><span>                          mountpointPath,
</span></span><span style="display:flex;"><span>                          <span style="color:#366">NULL</span> );
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p>Finally <code>__DACommandExecute</code> will run the command and set the EUID and EGID based on the info passed. Recall, this comes from the owner of the <code>/dev/</code> device.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#069;font-weight:bold">static</span> <span style="color:#078;font-weight:bold">void</span> <span style="color:#c0f">__DACommandExecute</span>( <span style="color:#078;font-weight:bold">char</span> <span style="color:#555">*</span> <span style="color:#069;font-weight:bold">const</span> <span style="color:#555">*</span>           argv,
</span></span><span style="display:flex;"><span>                                UInt32                   options,
</span></span><span style="display:flex;"><span>                                uid_t                    userUID,
</span></span><span style="display:flex;"><span>                                gid_t                    userGID,
</span></span><span style="display:flex;"><span>                                DACommandExecuteCallback callback,
</span></span><span style="display:flex;"><span>                                <span style="color:#078;font-weight:bold">void</span> <span style="color:#555">*</span>                   callbackContext )
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>    executablePID <span style="color:#555">=</span> fork( );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#069;font-weight:bold">if</span> ( executablePID <span style="color:#555">==</span> <span style="color:#f60">0</span> )
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#078;font-weight:bold">int</span> fd;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#09f;font-style:italic">/*
</span></span></span><span style="display:flex;"><span><span style="color:#09f;font-style:italic">         * Prepare the post-fork execution environment.
</span></span></span><span style="display:flex;"><span><span style="color:#09f;font-style:italic">         */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        setgid( userGID );
</span></span><span style="display:flex;"><span>        setuid( userUID );
</span></span></code></pre></div><p>This means that the <code>mount</code> command will be executed with the same rights as the owner of the <code>/dev</code> device.</p>
<h2 id="three---back-to-the-vulnerability-and-exploit">Three - Back to the Vulnerability and Exploit</h2>
<p>Originally the vulnerability was exploited by the authors using the <code>EFI</code> partition, which is owned by <code>root</code>, thus the mount is executed as root. They couldn&rsquo;t just mount an arbitrary DMG or image, an important part in the exploit was the ownership of the device. The actual mount and the <code>st.st_uid != DARequestGetUserUID( request )</code> check could be raced with a symlink.</p>
<p>Essentially there are no checks between the <code>mount</code> command execution and the ownership check, thus the race condition.</p>
<h2 id="four---the-fix">Four - The Fix</h2>
<p>Here is Apple&rsquo;s fix again:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#069;font-weight:bold">if</span> ( mountpoint )
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#069;font-weight:bold">if</span> ( DARequestGetUserUID( request ) )
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#069;font-weight:bold">if</span> ( DARequestGetUserUID( request ) <span style="color:#555">!=</span> DADiskGetUserUID( disk ) )
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            status <span style="color:#555">=</span> kDAReturnNotPermitted;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This is what I found initially very disturbing. Instead of verifying the owner of the target path, they verify if the owner of the device to be mounted is the same as the caller. Honestly this looked pretty odd, as it doesn&rsquo;t deal with the target location at all, but actually it&rsquo;s pretty clever, and here is why it works.</p>
<p>Case 1: As a user we want to mount a device, where the owner is <code>root</code>. We have to be <code>root</code> for that in order to satisfy the criteria. No LPE possible here, we can&rsquo;t mount the EFI anymore.
Case 2: As a user, we want to mount a device owned by our user over a location owned by <code>root</code>. The criteria will be satisfied, and DA will call mount. However as the device owner is the user, the <code>mount</code> command will be executed as the user, and it will eventually fail at the kernel level, as it will verify permissions. The ownership of the device is recorded only once at the very beginning, so no race condition is possible.</p>
<p>This is the case even today.</p>
<p>We can actually test this. Here we create a directory as <code>root</code>, and we want to mount over it a device as <code>root</code>, but where the device owner is the <code>user</code>. It will fail.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>csaby@mantarey /tmp % sudo mkdir mnt        
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>csaby@mantarey /tmp % ls -l /tmp/ | grep mnt
</span></span><span style="display:flex;"><span>drwxr-xr-x  <span style="color:#f60">2</span> root   wheel  <span style="color:#f60">64</span> Aug <span style="color:#f60">29</span> 21:15 mnt
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>csaby@mantarey /tmp % ls -l /dev/disk*
</span></span><span style="display:flex;"><span>brw-r-----  <span style="color:#f60">1</span> root   operator  0x1000000 Aug <span style="color:#f60">23</span> 15:20 /dev/disk0
</span></span><span style="display:flex;"><span>brw-r-----  <span style="color:#f60">1</span> root   operator  0x1000001 Aug <span style="color:#f60">23</span> 15:20 /dev/disk0s1
</span></span><span style="display:flex;"><span>brw-r-----  <span style="color:#f60">1</span> root   operator  0x1000002 Aug <span style="color:#f60">23</span> 15:20 /dev/disk0s2
</span></span><span style="display:flex;"><span>brw-r-----  <span style="color:#f60">1</span> root   operator  0x1000003 Aug <span style="color:#f60">23</span> 15:20 /dev/disk1
</span></span><span style="display:flex;"><span>brw-r-----  <span style="color:#f60">1</span> root   operator  0x1000004 Aug <span style="color:#f60">23</span> 15:20 /dev/disk1s1
</span></span><span style="display:flex;"><span>brw-r-----  <span style="color:#f60">1</span> root   operator  0x1000005 Aug <span style="color:#f60">23</span> 15:20 /dev/disk1s2
</span></span><span style="display:flex;"><span>brw-r-----  <span style="color:#f60">1</span> root   operator  0x1000008 Aug <span style="color:#f60">23</span> 15:20 /dev/disk1s3
</span></span><span style="display:flex;"><span>brw-r-----  <span style="color:#f60">1</span> root   operator  0x1000006 Aug <span style="color:#f60">23</span> 15:20 /dev/disk1s4
</span></span><span style="display:flex;"><span>brw-r-----  <span style="color:#f60">1</span> root   operator  0x1000009 Aug <span style="color:#f60">23</span> 15:20 /dev/disk1s5
</span></span><span style="display:flex;"><span>br--r-----  <span style="color:#f60">1</span> root   operator  0x100000a Aug <span style="color:#f60">23</span> 15:20 /dev/disk1s5s1
</span></span><span style="display:flex;"><span>brw-r-----  <span style="color:#f60">1</span> root   operator  0x1000007 Aug <span style="color:#f60">23</span> 15:20 /dev/disk1s6
</span></span><span style="display:flex;"><span>brw-r-----  <span style="color:#f60">1</span> csaby  staff     0x100000b Aug <span style="color:#f60">29</span> 19:33 /dev/disk2
</span></span><span style="display:flex;"><span>brw-r-----  <span style="color:#f60">1</span> csaby  staff     0x100000c Aug <span style="color:#f60">29</span> 19:33 /dev/disk2s1
</span></span><span style="display:flex;"><span>brw-r-----  <span style="color:#f60">1</span> csaby  staff     0x100000d Aug <span style="color:#f60">29</span> 19:33 /dev/disk3
</span></span><span style="display:flex;"><span>brw-r-----  <span style="color:#f60">1</span> csaby  staff     0x100000e Aug <span style="color:#f60">29</span> 19:33 /dev/disk3s1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>csaby@mantarey /tmp % sudo hdiutil mount  -mountPoint /tmp/mnt /dev/disk3s1
</span></span><span style="display:flex;"><span>hdiutil: mount failed - no mountable file systems
</span></span></code></pre></div><p>If we run ProcessMonitor in the background, we will find that the mount call is run as the user (UID: 501). Here the parent PID 97 is <code>diskarbitrationd</code>.</p>
<pre tabindex="0"><code>{&#34;event&#34;:&#34;ES_EVENT_TYPE_NOTIFY_EXIT&#34;,&#34;timestamp&#34;:&#34;2022-08-29 19:16:10 +0000&#34;,&#34;process&#34;:{&#34;pid&#34;:85347,&#34;name&#34;:&#34;mount&#34;,&#34;path&#34;:&#34;/sbin/mount&#34;,&#34;uid&#34;:501,&#34;architecture&#34;:&#34;unknown&#34;,&#34;arguments&#34;:[],&#34;ppid&#34;:97,&#34;rpid&#34;:97,&#34;ancestors&#34;:[97,1],&#34;signing info (reported)&#34;:{&#34;csFlags&#34;:570522385,&#34;platformBinary&#34;:1,&#34;signingID&#34;:&#34;com.apple.mount&#34;,&#34;teamID&#34;:&#34;&#34;,&#34;cdHash&#34;:&#34;85427FC991D8D020C57B4D566A89A49E1ED287FF&#34;},&#34;signing info (computed)&#34;:{&#34;signatureID&#34;:&#34;com.apple.mount&#34;,&#34;signatureStatus&#34;:0,&#34;signatureSigner&#34;:&#34;Apple&#34;,&#34;signatureAuthorities&#34;:[&#34;Software Signing&#34;,&#34;Apple Code Signing Certification Authority&#34;,&#34;Apple Root CA&#34;]},&#34;exit code&#34;:19200}}
{&#34;event&#34;:&#34;ES_EVENT_TYPE_NOTIFY_EXEC&#34;,&#34;timestamp&#34;:&#34;2022-08-29 19:16:10 +0000&#34;,&#34;process&#34;:{&#34;pid&#34;:85352,&#34;name&#34;:&#34;mount&#34;,&#34;path&#34;:&#34;/sbin/mount&#34;,&#34;uid&#34;:501,&#34;architecture&#34;:&#34;unknown&#34;,&#34;arguments&#34;:[&#34;/sbin/mount&#34;,&#34;-t&#34;,&#34;apfs&#34;,&#34;-o&#34;,&#34;nodev,noowners,nosuid&#34;,&#34;/dev/disk3s1&#34;,&#34;/private/tmp/mnt&#34;],&#34;ppid&#34;:97,&#34;rpid&#34;:97,&#34;ancestors&#34;:[97,1],&#34;signing info (reported)&#34;:{&#34;csFlags&#34;:570522385,&#34;platformBinary&#34;:1,&#34;signingID&#34;:&#34;com.apple.mount&#34;,&#34;teamID&#34;:&#34;&#34;,&#34;cdHash&#34;:&#34;85427FC991D8D020C57B4D566A89A49E1ED287FF&#34;},&#34;signing info (computed)&#34;:{&#34;signatureID&#34;:&#34;com.apple.mount&#34;,&#34;signatureStatus&#34;:0,&#34;signatureSigner&#34;:&#34;Apple&#34;,&#34;signatureAuthorities&#34;:[&#34;Software Signing&#34;,&#34;Apple Code Signing Certification Authority&#34;,&#34;Apple Root CA&#34;]}}}
</code></pre><p>This confirms my analysis. I think,</p>
<p>This all means that if the user owns the device, DA won&rsquo;t be able to mount it as root, because the executor and owner will be different. Problem? Likely not, maybe in some corner cases it can fail some code.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Not much. :) I&rsquo;m just glad that I finally understand what happened here. It was a pretty useful exercise.</p>
<p>If I made a mistake or wrong conclusion somewhere let me know.</p>

      </div>

      <footer>
        


        
      </footer>
    </article>

    
  </section>

      </div>

      <footer class="footer">
  <section class="container">
    
     © 2022
    
       · 
      Blog created by <a href="https://twitter.com/theevilbit">@theevilbit</a>.
    
    
  </section>
</footer>

    </main>

    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-151008930-1', 'auto');
	
	ga('send', 'pageview');
}
</script>

  </body>

</html>
