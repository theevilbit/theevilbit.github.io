<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <meta name="author" content="Csaba Fitzl">
    
    

    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="CVE-2020-9771 - Reversing Engineering the Fix"/>
<meta name="twitter:description" content="When I originally found the mount_apfs bug back in December, 2019, I honestly had no idea what was the root cause of it, nor had a clue how to even start looking into it. The only thing I knew for sure that the answer is within kernel. My macOS knowledge was still quite fresh that time (and even today), and was busy with so many other stuff that I never had the time to start looking into it."/>

    <meta property="og:title" content="CVE-2020-9771 - Reversing Engineering the Fix" />
<meta property="og:description" content="When I originally found the mount_apfs bug back in December, 2019, I honestly had no idea what was the root cause of it, nor had a clue how to even start looking into it. The only thing I knew for sure that the answer is within kernel. My macOS knowledge was still quite fresh that time (and even today), and was busy with so many other stuff that I never had the time to start looking into it." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://theevilbit.github.io/posts/reversing_cve_2020_9771/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-12-13T00:00:00&#43;00:00" />
<meta property="article:modified_time" content="2020-12-13T00:00:00&#43;00:00" />



    
      <base href="https://theevilbit.github.io/posts/reversing_cve_2020_9771/">
    
    <title>
  CVE-2020-9771 - Reversing Engineering the Fix · theevilbit blog
</title>

    
      <link rel="canonical" href="https://theevilbit.github.io/posts/reversing_cve_2020_9771/">
    

    <link href="https://fonts.googleapis.com/css?family=Lato:400,700%7CMerriweather:300,700%7CSource+Code+Pro:400,700" rel="stylesheet">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.8.1/css/all.css" integrity="sha384-50oBUHEmvpQ+1lW4y57PTFmhCaXp0ML5d60M1M7uH2+nqUivzIebhndOJK28anvf" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css" integrity="sha256-l85OmPOjvil/SOvVt3HnSSjzF1TUMyT9eV0c2BzEGzU=" crossorigin="anonymous" />

    
      
      
      <link rel="stylesheet" href="https://theevilbit.github.io/css/coder.min.28d751104f30c16da1aa1bb04015cbe662cacfe0d1b01af4f2240ad58580069c.css" integrity="sha256-KNdREE8wwW2hqhuwQBXL5mLKz&#43;DRsBr08iQK1YWABpw=" crossorigin="anonymous" media="screen" />
    

    

    

    

    
    
    <link rel="icon" type="image/png" href="https://theevilbit.github.io/images/favicon-32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="https://theevilbit.github.io/images/favicon-16x16.png" sizes="16x16">

    <meta name="generator" content="Hugo 0.84.1" />
  </head>

  <body class=" ">
    <main class="wrapper">
      <nav class="navigation">
  <section class="container">
    <a class="navigation-title" href="https://theevilbit.github.io/">
      theevilbit blog
    </a>
    <input type="checkbox" id="menu-toggle" />
    <label class="menu-button float-right" for="menu-toggle"><i class="fas fa-bars"></i></label>
    <ul class="navigation-list">
      
        
          <li class="navigation-item">
            <a class="navigation-link" href="https://theevilbit.github.io/posts/">Posts</a>
          </li>
        
          <li class="navigation-item">
            <a class="navigation-link" href="https://theevilbit.github.io/shield/">Shield.app</a>
          </li>
        
          <li class="navigation-item">
            <a class="navigation-link" href="https://theevilbit.github.io/beyond/">Beyond good ol&#39; LaunchAgents</a>
          </li>
        
          <li class="navigation-item">
            <a class="navigation-link" href="https://theevilbit.github.io/tags/">Tags</a>
          </li>
        
          <li class="navigation-item">
            <a class="navigation-link" href="https://theevilbit.github.io/categories/">Categories</a>
          </li>
        
          <li class="navigation-item">
            <a class="navigation-link" href="https://theevilbit.github.io/about/">About</a>
          </li>
        
      
      
    </ul>
  </section>
</nav>


      <div class="content">
        
  <section class="container post">
    <article>
      <header>
        <div class="post-title">
          <h1 class="title">CVE-2020-9771 - Reversing Engineering the Fix</h1>
        </div>
        <div class="post-meta">
          <div class="date">
            <span class="posted-on">
              <i class="fas fa-calendar"></i>
              <time datetime='2020-12-13T00:00:00Z'>
                December 13, 2020
              </time>
            </span>
            <span class="reading-time">
              <i class="fas fa-clock"></i>
              14 minutes read
            </span>
          </div>
          <div class="categories">
  <i class="fas fa-folder"></i>
    <a href="https://theevilbit.github.io/categories/blog/">BLOG</a></div>

          <div class="tags">
  <i class="fas fa-tag"></i>
    <a href="https://theevilbit.github.io/tags/lpe/">lpe</a>
      <span class="separator">•</span>
    <a href="https://theevilbit.github.io/tags/vulnerability/">vulnerability</a>
      <span class="separator">•</span>
    <a href="https://theevilbit.github.io/tags/macos/">macos</a>
      <span class="separator">•</span>
    <a href="https://theevilbit.github.io/tags/reverse-engineering/">reverse engineering</a></div>

        </div>
      </header>

      <div>
        <p>When I originally found the <code>mount_apfs</code> bug back in December, 2019, I honestly had no idea what was the root cause of it, nor had a clue how to even start looking into it. The only thing I knew for sure that the answer is within kernel. My macOS knowledge was still quite fresh that time (and even today), and was busy with so many other stuff that I never had the time to start looking into it.</p>
<p>Spring came, and Apple <a href="https://support.apple.com/en-us/HT211100">fixed</a> the bug in macOS Catalina 10.15.4, and they attributed this issue to the &ldquo;Sandbox&rdquo;. I changed jobs, summer came, and still didn&rsquo;t have time for it.</p>
<p>Now we are into one year since I originally reported this. Recently I came across an article about APFS snapshots, which was written back in 2017 by Adam Leventhal for Ars Technica. It&rsquo;s titled as <a href="https://arstechnica.com/gadgets/2017/02/testing-out-snapshots-in-apples-next-generation-apfs-file-system/">Testing out snapshots in Apple’s next-generation APFS file system</a>. This showed some system calls, which could be used for making APFS snapshots, and finally gave me a boost, and a pointer where to start looking.</p>
<p>I <a href="https://theevilbit.github.io/posts/cve_2020_9771/">previously</a> wrote about the vulnerability, which allowed someone to mount an APFS snapshot and gain read access to all files within the system, included those protected by privacy. The bug was fixed by only allowing apps having &ldquo;Full Disk Access&rdquo; right to make this mount operation.</p>
<p>So I finally decided to sit down and take an in-depth look into how Apple fixed it, and find out what&rsquo;s going on.</p>
<h2 id="chapter-1---the-source">Chapter 1 - The Source</h2>
<p>Although Apple doesn&rsquo;t open source everything, there is still a decent amount source code available, largely the XNU kernel, which is very useful for any similar investigation. Since image mounting is done via system calls, the source code of the XNU kernel can be very fruitful.</p>
<p><img src="https://theevilbit.github.io/images/Reversing_CVE_2020_9771/yoda.jpg" alt=""></p>
<p>During the past year Apple released the source code for XNU till macOS 10.15.6, so I decided to start looking there. I keep a copy of all tarballs, so extracted an earlier version of XNU, 6153.41.3 and also the one used in macOS 10.15.4, which is 6153.141.1. If any changes were made in the open source part we should see that. Let&rsquo;s try to find out if anything changed.</p>
<p>First we will start with tracking how snapshot mounting happens through system calls using <code>xnu-6153.41.3</code>. The file <code>./xnu-6153.41.3/libsyscall/wrappers/fs_snapshot.c</code> contains wrapper for various snapshot mounting related system calls. The one that is interesting for us is <code>fs_snapshot_mount</code>.</p>
<div class="highlight"><pre style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">fs_snapshot_mount(<span style="color:#078;font-weight:bold">int</span> dirfd, <span style="color:#069;font-weight:bold">const</span> <span style="color:#078;font-weight:bold">char</span> <span style="color:#555">*</span>dir, <span style="color:#069;font-weight:bold">const</span> <span style="color:#078;font-weight:bold">char</span> <span style="color:#555">*</span>snapshot,
    <span style="color:#078;font-weight:bold">uint32_t</span> flags)
{
	<span style="color:#069;font-weight:bold">return</span> __fs_snapshot(SNAPSHOT_OP_MOUNT, dirfd, snapshot, dir,
	           <span style="color:#366">NULL</span>, flags);
}
</code></pre></div><p>This function does a call to <code>fs_snapshot</code> with the opcode <code>SNAPSHOT_OP_MOUNT</code>. This function eventually leads to <code>fs_snapshot </code>, which can be found in <code>./xnu-6153.41.3/bsd/vfs/vfs_syscalls.c</code>. Here is a small section of it.</p>
<div class="highlight"><pre style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#09f;font-style:italic">/*
</span><span style="color:#09f;font-style:italic"> * FS snapshot operations dispatcher
</span><span style="color:#09f;font-style:italic"> */</span>
<span style="color:#078;font-weight:bold">int</span>
<span style="color:#c0f">fs_snapshot</span>(__unused proc_t p, <span style="color:#069;font-weight:bold">struct</span> fs_snapshot_args <span style="color:#555">*</span>uap,
    __unused <span style="color:#078;font-weight:bold">int32_t</span> <span style="color:#555">*</span>retval)
{
...
	<span style="color:#069;font-weight:bold">case</span> <span style="color:#99f">SNAPSHOT_OP_MOUNT</span>:
		error <span style="color:#555">=</span> snapshot_mount(uap<span style="color:#555">-&gt;</span>dirfd, uap<span style="color:#555">-&gt;</span>name1, uap<span style="color:#555">-&gt;</span>name2,
		    uap<span style="color:#555">-&gt;</span>data, uap<span style="color:#555">-&gt;</span>flags, ctx);
		<span style="color:#069;font-weight:bold">break</span>;
...
</code></pre></div><p>It&rsquo;s not a very long function, and at the very end it has a switch table, which is based on the opcodes passed. In our case it leads to  <code>snapshot_mount</code>. This function is in the same file, and it looks like the following.</p>
<div class="highlight"><pre style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#069;font-weight:bold">static</span> <span style="color:#078;font-weight:bold">int</span>
<span style="color:#c0f">snapshot_mount</span>(<span style="color:#078;font-weight:bold">int</span> dirfd, user_addr_t name, user_addr_t directory,
    __unused user_addr_t mnt_data, __unused <span style="color:#078;font-weight:bold">uint32_t</span> flags, vfs_context_t ctx)
{
	vnode_t rvp, snapdvp, snapvp, vp, pvp;
	<span style="color:#078;font-weight:bold">int</span> error;
	<span style="color:#069;font-weight:bold">struct</span> nameidata <span style="color:#555">*</span>snapndp, <span style="color:#555">*</span>dirndp;
	<span style="color:#09f;font-style:italic">/* carving out a chunk for structs that are too big to be on stack. */</span>
	<span style="color:#069;font-weight:bold">struct</span> {
		<span style="color:#069;font-weight:bold">struct</span> nameidata snapnd;
		<span style="color:#069;font-weight:bold">struct</span> nameidata dirnd;
	} <span style="color:#555">*</span> __snapshot_mount_data;

	MALLOC(__snapshot_mount_data, <span style="color:#078;font-weight:bold">void</span> <span style="color:#555">*</span>, <span style="color:#069;font-weight:bold">sizeof</span>(<span style="color:#555">*</span>__snapshot_mount_data),
	    M_TEMP, M_WAITOK);
	snapndp <span style="color:#555">=</span> <span style="color:#555">&amp;</span>__snapshot_mount_data<span style="color:#555">-&gt;</span>snapnd;
	dirndp <span style="color:#555">=</span> <span style="color:#555">&amp;</span>__snapshot_mount_data<span style="color:#555">-&gt;</span>dirnd;

	error <span style="color:#555">=</span> vnode_get_snapshot(dirfd, <span style="color:#555">&amp;</span>rvp, <span style="color:#555">&amp;</span>snapdvp, name, snapndp, LOOKUP,
	    OP_LOOKUP, ctx);
	<span style="color:#069;font-weight:bold">if</span> (error) {
		<span style="color:#069;font-weight:bold">goto</span> out;
	}

	snapvp  <span style="color:#555">=</span> snapndp<span style="color:#555">-&gt;</span>ni_vp;
	<span style="color:#069;font-weight:bold">if</span> (<span style="color:#555">!</span>vnode_mount(rvp) <span style="color:#555">||</span> (vnode_mount(rvp) <span style="color:#555">==</span> dead_mountp)) {
		error <span style="color:#555">=</span> EIO;
		<span style="color:#069;font-weight:bold">goto</span> out1;
	}

	<span style="color:#09f;font-style:italic">/* Get the vnode to be covered */</span>
	NDINIT(dirndp, LOOKUP, OP_MOUNT, FOLLOW <span style="color:#555">|</span> AUDITVNPATH1 <span style="color:#555">|</span> WANTPARENT,
	    UIO_USERSPACE, directory, ctx);
	error <span style="color:#555">=</span> namei(dirndp);
	<span style="color:#069;font-weight:bold">if</span> (error) {
		<span style="color:#069;font-weight:bold">goto</span> out1;
	}

	vp <span style="color:#555">=</span> dirndp<span style="color:#555">-&gt;</span>ni_vp;
	pvp <span style="color:#555">=</span> dirndp<span style="color:#555">-&gt;</span>ni_dvp;

	<span style="color:#069;font-weight:bold">if</span> ((vp<span style="color:#555">-&gt;</span>v_flag <span style="color:#555">&amp;</span> VROOT) <span style="color:#555">&amp;&amp;</span> (vp<span style="color:#555">-&gt;</span>v_mount<span style="color:#555">-&gt;</span>mnt_flag <span style="color:#555">&amp;</span> MNT_ROOTFS)) {
		error <span style="color:#555">=</span> EINVAL;
	} <span style="color:#069;font-weight:bold">else</span> {
		mount_t mp <span style="color:#555">=</span> vnode_mount(rvp);
		<span style="color:#069;font-weight:bold">struct</span> fs_snapshot_mount_args smnt_data;

		smnt_data.sm_mp  <span style="color:#555">=</span> mp;
		smnt_data.sm_cnp <span style="color:#555">=</span> <span style="color:#555">&amp;</span>snapndp<span style="color:#555">-&gt;</span>ni_cnd;
		error <span style="color:#555">=</span> mount_common(mp<span style="color:#555">-&gt;</span>mnt_vfsstat.f_fstypename, pvp, vp,
		    <span style="color:#555">&amp;</span>dirndp<span style="color:#555">-&gt;</span>ni_cnd, CAST_USER_ADDR_T(<span style="color:#555">&amp;</span>smnt_data), flags <span style="color:#555">&amp;</span> MNT_DONTBROWSE,
		    KERNEL_MOUNT_SNAPSHOT, <span style="color:#366">NULL</span>, FALSE, ctx);
	}

	vnode_put(vp);
	vnode_put(pvp);
	nameidone(dirndp);
<span style="color:#99f">out1</span>:
	vnode_put(snapvp);
	vnode_put(snapdvp);
	vnode_put(rvp);
	nameidone(snapndp);
<span style="color:#99f">out</span>:
	FREE(__snapshot_mount_data, M_TEMP);
	<span style="color:#069;font-weight:bold">return</span> error;
}
</code></pre></div><p>This function is eventually calls out to <code>mount_common</code>, which is also in the same file, and it will be responsible for the actual mount. Let&rsquo;s see how this function has changed, and for that we will use the code from <code>xnu-6153.141.1</code> specifically the file <code>./xnu-6153.141.1/bsd/vfs/vfs_syscalls.c</code>. I won&rsquo;t paste the entire function again, just the new important part.</p>
<div class="highlight"><pre style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#099">#if CONFIG_MACF
</span><span style="color:#099"></span>	error <span style="color:#555">=</span> mac_mount_check_snapshot_mount(ctx, rvp, vp, <span style="color:#555">&amp;</span>dirndp<span style="color:#555">-&gt;</span>ni_cnd, snapndp<span style="color:#555">-&gt;</span>ni_cnd.cn_nameptr,
	    mp<span style="color:#555">-&gt;</span>mnt_vfsstat.f_fstypename);
	<span style="color:#069;font-weight:bold">if</span> (error) {
		<span style="color:#069;font-weight:bold">goto</span> out2;
	}
<span style="color:#099">#endif
</span></code></pre></div><p>We can see that a callout to a MACF (Mandatory Access Control Framework) policy was added. On a very-very high level this is an extendable framework which can enforce various policies, restriction, and authorize or reject certain operations. On macOS the largest MACF policy extensions is the <code>Sandbox</code>. There are others, like <code>AppleMobileFileIntegrity</code>, but Sandbox is by far the largest with hooking more than 100 system calls.</p>
<p>This is where things start to make sense, because if we recall that Apple considered this a bug in &ldquo;Sandbox&rdquo;, this callout makes sense.</p>
<p>Apparently the bug is that a Sandbox check was missing. If we search for <code>mac_mount_*</code> in the old source code, we will see that there are many callouts, but not with the snapshot call, and specifically the <code>mac_mount_check_snapshot_mount</code> doesn&rsquo;t exists in earlier versions.</p>
<p>Let&rsquo;s move on. This function is defined in two places, first in <code>xnu-6153.141.1/security/mac_base.c</code>.</p>
<div class="highlight"><pre style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#078;font-weight:bold">int</span> <span style="color:#c0f">mac_mount_check_snapshot_mount</span>(vfs_context_t ctx, <span style="color:#069;font-weight:bold">struct</span> vnode <span style="color:#555">*</span>rvp, <span style="color:#069;font-weight:bold">struct</span> vnode <span style="color:#555">*</span>vp, <span style="color:#069;font-weight:bold">struct</span> componentname <span style="color:#555">*</span>cnp,
    <span style="color:#069;font-weight:bold">const</span> <span style="color:#078;font-weight:bold">char</span> <span style="color:#555">*</span>name, <span style="color:#069;font-weight:bold">const</span> <span style="color:#078;font-weight:bold">char</span> <span style="color:#555">*</span>vfc_name);
<span style="color:#078;font-weight:bold">int</span>
<span style="color:#c0f">mac_mount_check_snapshot_mount</span>(vfs_context_t ctx __unused, <span style="color:#069;font-weight:bold">struct</span> vnode <span style="color:#555">*</span>rvp __unused, <span style="color:#069;font-weight:bold">struct</span> vnode <span style="color:#555">*</span>vp __unused,
    <span style="color:#069;font-weight:bold">struct</span> componentname <span style="color:#555">*</span>cnp __unused, <span style="color:#069;font-weight:bold">const</span> <span style="color:#078;font-weight:bold">char</span> <span style="color:#555">*</span>name __unused, <span style="color:#069;font-weight:bold">const</span> <span style="color:#078;font-weight:bold">char</span> <span style="color:#555">*</span>vfc_name __unused)
{
	<span style="color:#069;font-weight:bold">return</span> <span style="color:#f60">0</span>;
}
</code></pre></div><p>Here this function simply returns 0, which in case of the MACF framework, means &ldquo;allow&rdquo;. I&rsquo;m guessing here, but I think this is just to ensure that if none of the MACF policy hooks support this check, the operation will be allowed. I think this is like a default allow action.</p>
<p>The other implementation is in <code>xnu-6153.141.1/security/mac_vfs.c</code>.</p>
<div class="highlight"><pre style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">mac_mount_check_snapshot_mount(vfs_context_t ctx, <span style="color:#069;font-weight:bold">struct</span> vnode <span style="color:#555">*</span>rvp, <span style="color:#069;font-weight:bold">struct</span> vnode <span style="color:#555">*</span>vp, <span style="color:#069;font-weight:bold">struct</span> componentname <span style="color:#555">*</span>cnp,
    <span style="color:#069;font-weight:bold">const</span> <span style="color:#078;font-weight:bold">char</span> <span style="color:#555">*</span>name, <span style="color:#069;font-weight:bold">const</span> <span style="color:#078;font-weight:bold">char</span> <span style="color:#555">*</span>vfc_name)
{
	kauth_cred_t cred;
	<span style="color:#078;font-weight:bold">int</span> error;

<span style="color:#099">#if SECURITY_MAC_CHECK_ENFORCE
</span><span style="color:#099"></span>	<span style="color:#09f;font-style:italic">/* 21167099 - only check if we allow write */</span>
	<span style="color:#069;font-weight:bold">if</span> (<span style="color:#555">!</span>mac_vnode_enforce) {
		<span style="color:#069;font-weight:bold">return</span> <span style="color:#f60">0</span>;
	}
<span style="color:#099">#endif
</span><span style="color:#099"></span>	cred <span style="color:#555">=</span> vfs_context_ucred(ctx);
	<span style="color:#069;font-weight:bold">if</span> (<span style="color:#555">!</span>mac_cred_check_enforce(cred)) {
		<span style="color:#069;font-weight:bold">return</span> <span style="color:#f60">0</span>;
	}
	VFS_KERNEL_DEBUG_START1(<span style="color:#f60">92</span>, vp);
	MAC_CHECK(mount_check_snapshot_mount, cred, rvp, vp, cnp, name, vfc_name);
	VFS_KERNEL_DEBUG_END1(<span style="color:#f60">92</span>, vp);
	<span style="color:#069;font-weight:bold">return</span> error;
} 
</code></pre></div><p>This function uses the macro <code>MAC_CHECK</code>. This is defined in <code>./xnu-6153.141.1/security/mac_internal.h</code>.</p>
<div class="highlight"><pre style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#099">#define MAC_CHECK(check, args...) do {                                  \
</span><span style="color:#099">	struct mac_policy_conf *mpc;                                    \
</span><span style="color:#099">	u_int i;                                                        \
</span><span style="color:#099">                                                                        \
</span><span style="color:#099">	error = 0;                                                      \
</span><span style="color:#099">	for (i = 0; i &lt; mac_policy_list.staticmax; i++) {               \
</span><span style="color:#099">	        mpc = mac_policy_list.entries[i].mpc;                   \
</span><span style="color:#099">	        if (mpc == NULL)                                        \
</span><span style="color:#099">	                continue;                                       \
</span><span style="color:#099">                                                                        \
</span><span style="color:#099">	        if (mpc-&gt;mpc_ops-&gt;mpo_ ## check != NULL)                \
</span><span style="color:#099">	                error = mac_error_select(                       \
</span><span style="color:#099">	                    mpc-&gt;mpc_ops-&gt;mpo_ ## check (args),         \
</span><span style="color:#099">	                    error);                                     \
</span><span style="color:#099">	}                                                               \
</span><span style="color:#099">	if (mac_policy_list_conditional_busy() != 0) {                  \
</span><span style="color:#099">	        for (; i &lt;= mac_policy_list.maxindex; i++) {            \
</span><span style="color:#099">	                mpc = mac_policy_list.entries[i].mpc;           \
</span><span style="color:#099">	                if (mpc == NULL)                                \
</span><span style="color:#099">	                        continue;                               \
</span><span style="color:#099">                                                                        \
</span><span style="color:#099">	                if (mpc-&gt;mpc_ops-&gt;mpo_ ## check != NULL)        \
</span><span style="color:#099">	                        error = mac_error_select(               \
</span><span style="color:#099">	                            mpc-&gt;mpc_ops-&gt;mpo_ ## check (args), \
</span><span style="color:#099">	                            error);                             \
</span><span style="color:#099">	        }                                                       \
</span><span style="color:#099">	        mac_policy_list_unbusy();                               \
</span><span style="color:#099">	}                                                               \
</span><span style="color:#099">} while (0)
</span></code></pre></div><p>Eventually this macro will iterate over all MACF policy extension, and call the related function. There are many callouts to <code>mac_error_select</code> function, which is implemented in <code>./xnu-6153.141.1/security/mac_base.c</code>.</p>
<div class="highlight"><pre style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#09f;font-style:italic">/*
</span><span style="color:#09f;font-style:italic"> * Define an error value precedence, and given two arguments, selects the
</span><span style="color:#09f;font-style:italic"> * value with the higher precedence.
</span><span style="color:#09f;font-style:italic"> */</span>
<span style="color:#078;font-weight:bold">int</span>
<span style="color:#c0f">mac_error_select</span>(<span style="color:#078;font-weight:bold">int</span> error1, <span style="color:#078;font-weight:bold">int</span> error2)
{
	<span style="color:#09f;font-style:italic">/* Certain decision-making errors take top priority. */</span>
	<span style="color:#069;font-weight:bold">if</span> (error1 <span style="color:#555">==</span> EDEADLK <span style="color:#555">||</span> error2 <span style="color:#555">==</span> EDEADLK) {
		<span style="color:#069;font-weight:bold">return</span> EDEADLK;
	}

	<span style="color:#09f;font-style:italic">/* Invalid arguments should be reported where possible. */</span>
	<span style="color:#069;font-weight:bold">if</span> (error1 <span style="color:#555">==</span> EINVAL <span style="color:#555">||</span> error2 <span style="color:#555">==</span> EINVAL) {
		<span style="color:#069;font-weight:bold">return</span> EINVAL;
	}

	<span style="color:#09f;font-style:italic">/* Precedence goes to &#34;visibility&#34;, with both process and file. */</span>
	<span style="color:#069;font-weight:bold">if</span> (error1 <span style="color:#555">==</span> ESRCH <span style="color:#555">||</span> error2 <span style="color:#555">==</span> ESRCH) {
		<span style="color:#069;font-weight:bold">return</span> ESRCH;
	}

	<span style="color:#069;font-weight:bold">if</span> (error1 <span style="color:#555">==</span> ENOENT <span style="color:#555">||</span> error2 <span style="color:#555">==</span> ENOENT) {
		<span style="color:#069;font-weight:bold">return</span> ENOENT;
	}

	<span style="color:#09f;font-style:italic">/* Precedence goes to DAC/MAC protections. */</span>
	<span style="color:#069;font-weight:bold">if</span> (error1 <span style="color:#555">==</span> EACCES <span style="color:#555">||</span> error2 <span style="color:#555">==</span> EACCES) {
		<span style="color:#069;font-weight:bold">return</span> EACCES;
	}

	<span style="color:#09f;font-style:italic">/* Precedence goes to privilege. */</span>
	<span style="color:#069;font-weight:bold">if</span> (error1 <span style="color:#555">==</span> EPERM <span style="color:#555">||</span> error2 <span style="color:#555">==</span> EPERM) {
		<span style="color:#069;font-weight:bold">return</span> EPERM;
	}

	<span style="color:#09f;font-style:italic">/* Precedence goes to error over success; otherwise, arbitrary. */</span>
	<span style="color:#069;font-weight:bold">if</span> (error1 <span style="color:#555">!=</span> <span style="color:#f60">0</span>) {
		<span style="color:#069;font-weight:bold">return</span> error1;
	}
	<span style="color:#069;font-weight:bold">return</span> error2;
}
</code></pre></div><p>What it does is comparing the error messages returned by the various MACF policy extensions, and ensure that if one of those didn&rsquo;t allow the operation, it will return the error accordingly. There is a certain priority for the various errors, and the &ldquo;highest&rdquo; will be returned. This also means that if any of the extension denies the action, it will be denied.</p>
<p>The fact that a 0 is expected as return for an allowed operation is well documented at the <code>mpo_mount_check_snapshot_mount_t</code> type definition inside <code>./xnu-6153.141.1/security/mac_policy.h</code>.</p>
<div class="highlight"><pre style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#09f;font-style:italic">/**
</span><span style="color:#09f;font-style:italic"> *  @brief Access control check for fs_snapshot_mount
</span><span style="color:#09f;font-style:italic"> *  @param cred Subject credential
</span><span style="color:#09f;font-style:italic"> *  @param rvp Vnode of either the root directory of the
</span><span style="color:#09f;font-style:italic"> *  filesystem to mount snapshot of, or the device from
</span><span style="color:#09f;font-style:italic"> *  which to mount the snapshot.
</span><span style="color:#09f;font-style:italic"> *  @param vp Vnode that is to be the mount point
</span><span style="color:#09f;font-style:italic"> *  @param cnp Component name for vp
</span><span style="color:#09f;font-style:italic"> *  @param name Name of snapshot to mount
</span><span style="color:#09f;font-style:italic"> *  @param vfc_name Filesystem type name
</span><span style="color:#09f;font-style:italic"> *
</span><span style="color:#09f;font-style:italic"> *  Determine whether the subject identified by the credential can
</span><span style="color:#09f;font-style:italic"> *  mount the named snapshot from the filesystem at the given
</span><span style="color:#09f;font-style:italic"> *  directory.
</span><span style="color:#09f;font-style:italic"> *
</span><span style="color:#09f;font-style:italic"> *  @return Return 0 if access is granted, otherwise an appropriate value
</span><span style="color:#09f;font-style:italic"> *  for errno should be returned.
</span><span style="color:#09f;font-style:italic"> */</span>
<span style="color:#069;font-weight:bold">typedef</span> <span style="color:#078;font-weight:bold">int</span> <span style="color:#c0f">mpo_mount_check_snapshot_mount_t</span>(
	kauth_cred_t cred,
	<span style="color:#069;font-weight:bold">struct</span> vnode <span style="color:#555">*</span>rvp,
	<span style="color:#069;font-weight:bold">struct</span> vnode <span style="color:#555">*</span>vp,
	<span style="color:#069;font-weight:bold">struct</span> componentname <span style="color:#555">*</span>cnp,
	<span style="color:#069;font-weight:bold">const</span> <span style="color:#078;font-weight:bold">char</span> <span style="color:#555">*</span>name,
	<span style="color:#069;font-weight:bold">const</span> <span style="color:#078;font-weight:bold">char</span> <span style="color:#555">*</span>vfc_name
	);
</code></pre></div><p>It says <code>@return Return 0 if access is granted</code>. This is generally true for all MACF calls, not just this.</p>
<p>An interesting thing I found is that in order to use the  <code>fs_snaphot</code> system call, which is also used by <a href="https://github.com/ahl/apfs">snapUtil</a>, and not get denied, you need the <code>com.apple.developer.vfs.snapshot</code> entitlement.</p>
<p>Now that we now that there is a MACF call, time to take a look on the Sandbox. For this we will use the Sandbox extension from Big Sur instead of Catalina.</p>
<h2 id="chapter-2---the-sandbox">Chapter 2 - The Sandbox</h2>
<p>The <code>mount_check_snapshot_mount</code> Sandbox hook is implemented by the <code>hook_mount_check_snapshot_mount</code> function.</p>
<pre><code class="language-clike" data-lang="clike">int _hook_mount_check_snapshot_mount(int arg0, int arg1, int arg2, int arg3, int arg4, int arg5) {
    var_30 = **qword_44080;
    var_40 = 0xaaaaaaaaaaaaaaaa;
    *(&amp;var_40 + 0x8) = 0xaaaaaaaaaaaaaaaa;
    ___strlcpy_chk(&amp;var_40, arg5, 0x10, 0x10, arg4, arg5);
    ___bzero(&amp;var_1C8, 0x188);
    *(int32_t *)(&amp;var_1C8 + 0xa8) = 0x1;
    *(&amp;var_1C8 + 0xb0) = arg2;
    *(&amp;var_1C8 + 0x118) = &amp;var_40;
    *(&amp;var_1C8 + 0x120) = arg4;
    rax = _cred_sb_evaluate(arg0, 0x2c, &amp;var_1C8, 0x10, arg4, arg5);
    if (**qword_44080 != var_30) {
            rax = ___stack_chk_fail();
    }
    return rax;
}
</code></pre><p>This is a short function, which calls into <code>cred_sb_evaluate</code> with the opcode 0x2c. It&rsquo;s very common for Sandbox hook functions, to be short, and pass evaluation for the <code>cred_sb_evaluate</code> function with a given opcode.</p>
<pre><code class="language-clike" data-lang="clike">int _cred_sb_evaluate(int arg0, int arg1, int arg2, int arg3, int arg4, int arg5) {
    r9 = arg5;
    r8 = arg4;
    rdi = arg0;
    r15 = arg2;
    r14 = arg1;
    *(arg2 + 0x20) = rdi;
    if (rdi &lt; 0x1) {
            rbx = 0x0;
    }
    else {
            rbx = _label_get_sandbox(*(rdi + 0x78));
    }
    var_50 = *qword_44008;
    *(&amp;var_50 + 0x8) = 0x40000000;
    *(&amp;var_50 + 0x10) = ___sb_evaluate_block_invoke;
    *(&amp;var_50 + 0x18) = ___block_descriptor_tmp.16;
    *(&amp;var_50 + 0x20) = rbx;
    *(int32_t *)(&amp;var_50 + 0x30) = r14;
    *(&amp;var_50 + 0x28) = r15;
    _sb_evaluate_internal(rbx, r14, r15, &amp;var_50, r8, r9);
    _sandbox_release(rbx, r14);
    rax = rax;
    return rax;
}
</code></pre><p><code>cred_sb_evaluate</code> is also not very long and it further calls into <code>sb_evaluate_internal</code>, passing the opcode. This is a massive, and very complex function, and ultimately this is what will determine if the operation is allowed or not. Most hook operations end up calling into this internal function. It&rsquo;s over 1000 lines of code even if decompiled.</p>
<p>I decided not to fully reverse engineer this as in itself it would be weeks of work, but I still wanted to see the decision making process, so jumped into kernel debugging. I wrote about how to do kernel debugging on macOS earlier, which can be found in my company&rsquo;s website, here: <a href="https://www.offensive-security.com/offsec/kernel-debugging-macos-with-sip/">Kernel Debugging macOS with SIP</a>.</p>
<blockquote>
<p>A small detour. Kernel debugging on Big Sur, with VMware Fusion 12.1 doesn&rsquo;t work well if the VM has more than 1 vCPU. No matter if we use VMware&rsquo;s GDB stub or proper XNU kernel debugging, when we &ldquo;continue&rdquo; after a breakpoint, the VM will hang forever and the &ldquo;vmware-vmx&rdquo; process will go high on CPU. This could also happen with 1 vCPU, but rarely.</p>
</blockquote>
<p>Once kernel debugging is going, we start by setting a breakpoint on <code>hook_mount_check_snapshot_mount</code> and continue.</p>
<pre><code>(lldb) b hook_mount_check_snapshot_mount
Breakpoint 1: where = Sandbox`hook_mount_check_snapshot_mount, address = 0xffffff801021a49c
(lldb) c
Process 1 resuming
</code></pre><p>Then we issue a snapshot mount in Terminal to trigger the breakpoint. We do this first from a Terminal, which has no Full Disk Access set.</p>
<pre><code>mount_apfs -o noowners,ro -s com.apple.TimeMachine.2020-12-04-045333.local /System/Volumes/Data /tmp/snap
</code></pre><p>We will hit our breakpoint.</p>
<pre><code>Process 1 stopped
* thread #3, name = '0xffffff86a42b4000', queue = 'cpu-0', stop reason = breakpoint 1.1
    frame #0: 0xffffff801021a49c Sandbox`hook_mount_check_snapshot_mount
Sandbox`hook_mount_check_snapshot_mount:
-&gt;  0xffffff801021a49c &lt;+0&gt;: int3   
    0xffffff801021a49d &lt;+1&gt;: mov    rbp, rsp
    0xffffff801021a4a0 &lt;+4&gt;: push   r15
    0xffffff801021a4a2 &lt;+6&gt;: push   r14
Target 0: (kernel) stopped.
</code></pre><p>We can step through the execution till <code>sb_evaluate_internal</code> returns and then check the value of RAX, which contains the return value, and the &ldquo;decision&rdquo; of the evaluation.</p>
<pre><code>(lldb)  
Process 1 stopped
* thread #3, name = '0xffffff86a42b4000', queue = 'cpu-0', stop reason = instruction step over
    frame #0: 0xffffff8010217f57 Sandbox`cred_sb_evaluate + 119
Sandbox`cred_sb_evaluate:
-&gt;  0xffffff8010217f57 &lt;+119&gt;: mov    r14, rax
    0xffffff8010217f5a &lt;+122&gt;: mov    rdi, rbx
    0xffffff8010217f5d &lt;+125&gt;: call   0xffffff801021713d        ; sandbox_release
    0xffffff8010217f62 &lt;+130&gt;: mov    rax, r14
Target 0: (kernel) stopped.
(lldb) register read $rax
     rax = 0x00000001ffffffff
</code></pre><p>We can see that the return value is <code>0x00000001ffffffff</code>, which is definitely not 0, which means that the operation is not allowed. This will be eventually returned upwards.</p>
<p>If we check the backtrace we will see that we got here through slightly different system call, compared to what we checked originally in the XNU source code.</p>
<pre><code>(lldb) bt
* thread #3, name = '0xffffff86a42b4000', queue = 'cpu-0', stop reason = instruction step over
  * frame #0: 0xffffff8010217f6c Sandbox`cred_sb_evaluate + 140
    frame #1: 0xffffff801021a535 Sandbox`hook_mount_check_snapshot_mount + 153
    frame #2: 0xffffff800daafe3f kernel`mac_mount_check_snapshot_mount(ctx=&lt;unavailable&gt;, rvp=0xffffff869e187200, vp=0xffffff86ae81bd00, cnp=0x0000000000000000, name=&quot;com.apple.TimeMachine.2020-12-11-135636.local&quot;, vfc_name=&quot;apfs&quot;) at mac_vfs.c:2376:2 [opt]
    frame #3: 0xffffff80102eb5fb apfs`handle_snapshot_mount + 4808
    frame #4: 0xffffff80102e5524 apfs`apfs_vfsop_mount + 9469
    frame #5: 0xffffff800d54f198 kernel`mount_common(fstypename=&lt;unavailable&gt;, pvp=0xffffff869e54d200, vp=&lt;unavailable&gt;, cnp=&lt;unavailable&gt;, fsmountargs=140732678379552, flags=2097177, internal_flags=0, labelstr=0x0000000000000000, kernelmount=0, ctx=0xffffff86a3f57438) at vfs_syscalls.c:1220:11 [opt]
    frame #6: 0xffffff800d551145 kernel`__mac_mount(p=&lt;unavailable&gt;, uap=0xffffffa04e8fbf18, retval=&lt;unavailable&gt;) at vfs_syscalls.c:596:10 [opt]
    frame #7: 0xffffff800d550cfe kernel`mount(p=&lt;unavailable&gt;, uap=&lt;unavailable&gt;, retval=&lt;unavailable&gt;) at vfs_syscalls.c:356:9 [opt]
    frame #8: 0xffffff800d969ceb kernel`unix_syscall64(state=&lt;unavailable&gt;) at systemcalls.c:412:10 [opt]
    frame #9: 0xffffff800d2621f6 kernel`hndl_unix_scall64 + 22
</code></pre><p>We can see that <code>mount_apfs</code> called the <code>mount</code> system call, instead of the <code>fs_snapshot</code>, and <code>mount_common</code> eventually called into the <code>apfs</code> kernel extension to handle the mount operation. Then <code>apfs</code> called <code>mac_mount_check_snapshot_mount</code> what we saw earlier.</p>
<p>If we open <code>apfs</code> in Hopper and navigate to this function, we will find this callout.</p>
<pre><code class="language-clike" data-lang="clike">int _handle_snapshot_mount(int arg0, int arg1, int arg2, int arg3, int arg4, int arg5) {
...
rax = _mac_mount_check_snapshot_mount(var_528, rsi, rdx, rcx, r8, r9);
...
</code></pre><p>Now let&rsquo;s give Terminal &ldquo;Full Disk Access&rdquo; rights, and try mounting again.</p>
<pre><code>(lldb) b 0xffffff8010217f5a
Breakpoint 4: where = Sandbox`cred_sb_evaluate + 122, address = 0xffffff8010217f5a
(lldb) c
Process 1 resuming
Process 1 stopped
* thread #12, name = '0xffffff86a00a36c0', queue = 'cpu-0', stop reason = breakpoint 4.1
    frame #0: 0xffffff8010217f5a Sandbox`cred_sb_evaluate + 122
Sandbox`cred_sb_evaluate:
-&gt;  0xffffff8010217f5a &lt;+122&gt;: int3   
    0xffffff8010217f5b &lt;+123&gt;: mov    edi, ebx
    0xffffff8010217f5d &lt;+125&gt;: call   0xffffff801021713d        ; sandbox_release
    0xffffff8010217f62 &lt;+130&gt;: mov    rax, r14
Target 0: (kernel) stopped.
(lldb) bt
* thread #12, name = '0xffffff86a00a36c0', queue = 'cpu-0', stop reason = breakpoint 4.1
  * frame #0: 0xffffff8010217f5a Sandbox`cred_sb_evaluate + 122
    frame #1: 0xffffff801021a535 Sandbox`hook_mount_check_snapshot_mount + 153
    frame #2: 0xffffff800daafe3f kernel`mac_mount_check_snapshot_mount(ctx=&lt;unavailable&gt;, rvp=0xffffff869e187200, vp=0xffffff86ae81bd00, cnp=0x0000000000000000, name=&quot;com.apple.TimeMachine.2020-12-11-135636.local&quot;, vfc_name=&quot;apfs&quot;) at mac_vfs.c:2376:2 [opt]
    frame #3: 0xffffff80102eb5fb apfs`handle_snapshot_mount + 4808
    frame #4: 0xffffff80102e5524 apfs`apfs_vfsop_mount + 9469
    frame #5: 0xffffff800d54f198 kernel`mount_common(fstypename=&lt;unavailable&gt;, pvp=0xffffff869e54d200, vp=&lt;unavailable&gt;, cnp=&lt;unavailable&gt;, fsmountargs=140732897724560, flags=2097177, internal_flags=0, labelstr=0x0000000000000000, kernelmount=0, ctx=0xffffff86a35383b0) at vfs_syscalls.c:1220:11 [opt]
    frame #6: 0xffffff800d551145 kernel`__mac_mount(p=&lt;unavailable&gt;, uap=0xffffffa04e7e3f18, retval=&lt;unavailable&gt;) at vfs_syscalls.c:596:10 [opt]
    frame #7: 0xffffff800d550cfe kernel`mount(p=&lt;unavailable&gt;, uap=&lt;unavailable&gt;, retval=&lt;unavailable&gt;) at vfs_syscalls.c:356:9 [opt]
    frame #8: 0xffffff800d969ceb kernel`unix_syscall64(state=&lt;unavailable&gt;) at systemcalls.c:412:10 [opt]
    frame #9: 0xffffff800d2621f6 kernel`hndl_unix_scall64 + 22
(lldb) register read $rax
     rax = 0x0000000000000000
</code></pre><p>Once we hit our breakpoint we will set a new breakpoint which is hit upon returning from <code>sb_evaluate_internal</code>. Now if we check the value of <code>RAX</code>, we will find that the return value is &ldquo;0&rdquo;, and our operation will indeed be successful. This confirms that indeed this is where the decision happens, and this check was missing prior Catalina 10.15.4.</p>
<p>If we do a binary diffing on the Sandbox between macOS version 10.15.3 and 10.15.4 we will see that the function <code>hook_mount_check_snapshot_mount</code> was introduced at this version.</p>
<h2 id="conclusion">Conclusion</h2>
<p>In this rather long post we explored the secrets behind the fix for CVE-2020-9771. We started with reviewing the changes in the XNU source code, and found that a new MACF policy check, <code>mac_mount_check_snapshot_mount</code> was introduced for snapshot mounting. Then we moved over the Sandbox, where we examined the <code>hook_mount_check_snapshot_mount</code> function, which implements this check by calling into <code>sb_evaluate_internal</code>. Lastly we used kernel debugging to confirm the decision made by the Sandbox and compare the results of having and not having FDA rights.</p>
<p>I hope this was a useful article, I certainly learned a lot by going through this process. I think I will always feel like a n00b, no matter what, but now at least I&rsquo;m one step forward.</p>
<p><img src="https://theevilbit.github.io/images/Reversing_CVE_2020_9771/babyyoda.jpg" alt=""></p>

      </div>

      <footer>
        


        
      </footer>
    </article>

    
  </section>

      </div>

      <footer class="footer">
  <section class="container">
    
     © 2021
    
       · 
      Blog created by <a href="https://twitter.com/theevilbit">@theevilbit</a>.
    
    
  </section>
</footer>

    </main>

    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-151008930-1', 'auto');
	
	ga('send', 'pageview');
}
</script>

  </body>

</html>
